//! Hypervisor logger. Logging info generated by Rustcracker.

use fs2::FileExt;
use std::fs::OpenOptions;
use std::io::{self, Write};
use std::path::PathBuf;
use std::sync::Arc;

#[derive(Debug, thiserror::Error)]
pub enum LoggerError {
    #[error("fail to communicate with file system: {0}")]
    FilesysIO(String),
    #[error("fail locking: {0}")]
    Lock(String),
}

pub type LoggerResult<T> = std::result::Result<T, LoggerError>;

#[derive(Debug, Clone)]
pub enum LogTo {
    Stdout,
    File(PathBuf),
}
pub struct HPLogger {
    id: Option<String>,
    log_to: LogTo,
    open_file: Option<Arc<std::fs::File>>,
}

impl HPLogger {
    pub fn new(id: Option<String>, log_to: LogTo) -> LoggerResult<Self> {
        let open_file = match &log_to {
            LogTo::Stdout => None,
            LogTo::File(ref path) => {
                let file = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)
                    .map_err(|e| LoggerError::FilesysIO(e.to_string()))?;
                Some(Arc::new(file))
            }
        };

        Ok(HPLogger {
            id,
            log_to,
            open_file,
        })
    }

    pub fn log(&self, level: log::Level, msg: &str) {
        let id = match &self.id {
            None => "null",
            Some(s) => s.as_str(),
        };
        match &self.log_to {
            LogTo::Stdout => {
                let mut stdout = io::stdout();
                writeln!(stdout, "{} [{}] {}", id, level, msg).unwrap();
            }
            LogTo::File(_) => {
                if let Some(file) = &self.open_file {
                    let mut file = file.clone();
                    file.lock_exclusive().unwrap();
                    writeln!(file, "{} [{}] {}", id, level, msg).unwrap();
                    file.unlock().unwrap();
                }
            }
        }
    }
}

// Implementing Log trait for HPLogger to integrate with the `log` crate.
impl log::Log for HPLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.level() <= log::Level::Info
    }

    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            self.log(record.level(), &record.args().to_string());
        }
    }

    fn flush(&self) {}
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn demo() {
        let logger1 = HPLogger::new(None, LogTo::File("rtck-test-output.log1".into())).unwrap();
        let logger2 = HPLogger::new(
            Some("demo-instance".into()),
            LogTo::File("rtck-test-output.log2".into()),
        )
        .unwrap();

        log::set_boxed_logger(Box::new(logger1))
            .map(|()| log::set_max_level(log::LevelFilter::Info))
            .unwrap();

        log::error!("This is an error message from logger1!");
        log::info!("This is an info message from logger1!");

        // You can also use logger2 to log messages.
        logger2.log(log::Level::Error, "This is an error message from logger2!");
        logger2.log(log::Level::Info, "This is an info message from logger2!");
    }
}

pub fn global_init() {
    let global_logger = HPLogger::new(None, LogTo::Stdout).unwrap();
    log::set_boxed_logger(Box::new(global_logger))
        .map(|()| log::set_max_level(log::LevelFilter::Info))
        .unwrap();
}
